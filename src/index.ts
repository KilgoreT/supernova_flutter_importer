import { Supernova, PulsarContext, RemoteVersionIdentifier, AnyOutputFile } from "@supernovaio/sdk-exporters"
import { ExporterConfiguration } from "../config"
import { FileHelper } from "@supernovaio/export-helpers"
import { generateTypography } from "src/content/typography";
import { buildTokenTree } from "src/core/build-tree"
import { toIToken, toITokenGroup } from "src/core/entity/core";
import { pruneTokenTree } from "src/core/prune-tree";
import { generateColors } from "src/content/color";
// import { DefinedTokenType, filterTreeByTokenType } from "./content";
// import { printTokenGroupTree } from "src/core/build-tree";
import { generateShadow } from "./content/shadow";
import { dartKeywords } from "./utils/sanitize";

/**
 * Export entrypoint.
 * When running `export` through extensions or pipelines, this function will be called.
 * Context contains information about the design system and version that is currently being exported.
 */
Pulsar.export(async (sdk: Supernova, context: PulsarContext): Promise<Array<AnyOutputFile>> => {
  // Fetch data from design system that is currently being exported (context)
  const remoteVersionIdentifier: RemoteVersionIdentifier = {
    designSystemId: context.dsId,
    versionId: context.versionId,
  }

  // Fetch the necessary data
  const tokens = await sdk.tokens.getTokens(remoteVersionIdentifier)
  const tokenGroups = await sdk.tokens.getTokenGroups(remoteVersionIdentifier)

  // Filter by brand, if specified by the VSCode extension or pipeline configuration
  // if (context.brandId) {
  //   const brands = await sdk.brands.getBrands(remoteVersionIdentifier)
  //   const brand = brands.find((brand) => brand.id === context.brandId || brand.idInVersion === context.brandId)
  //   if (!brand) {
  //     throw new Error(`Unable to find brand ${context.brandId}.`)
  //   }

  //   tokens = tokens.filter((token) => token.brandId === brand.id)
  //   tokenGroups = tokenGroups.filter((tokenGroup) => tokenGroup.brandId === brand.id)
  // }

  // Apply themes, if specified
  // if (context.themeIds && context.themeIds.length > 0) {
  //   const themes = await sdk.tokens.getTokenThemes(remoteVersionIdentifier)

  //   const themesToApply = context.themeIds.map((themeId) => {
  //     const theme = themes.find((theme) => theme.id === themeId || theme.idInVersion === themeId)
  //     if (!theme) {
  //       throw new Error(`Unable to find theme ${themeId}.`)
  //     }
  //     return theme
  //   })

  //   tokens = sdk.tokens.computeTokensByApplyingThemes(tokens, tokens, themesToApply)
  // }

  // Convert all color tokens to CSS variables
  // const mappedTokens = new Map(tokens.map((token) => [token.id, token]))
  // const cssVariables = tokens
  //   .filter((t) => t.tokenType === TokenType.color)
  //   .map((token) => colorTokenToCSS(token as ColorToken, mappedTokens, tokenGroups))
  //   .join("\n")

  // Create CSS file content
  // let content = `:root {\n${cssVariables}\n}`


  // // Create output file and return it
  // return [
  //   FileHelper.createTextFile({
  //     relativePath: "./",
  //     fileName: "colors.dart",
  //     content: content,
  //   }),
  // ]

  const tree = buildTokenTree(
    tokenGroups.map(toITokenGroup),
    tokens.map(toIToken)
  );

  const basePath = exportConfiguration.basePath;
  console.log(`>>>>> Base path: ${basePath}`);
  const prunedTree = pruneTokenTree(tree);
  // const shadowed = filterTreeByTokenType(tree, DefinedTokenType.Shadow);
  // printTokenGroupTree(shadowed);

  // const colorGroups = tokenGroups.filter(g => g.tokenType === TokenType.color);
  // const colorTokens = tokens.filter((t): t is ColorToken => t.tokenType === TokenType.color);
  // const colorFiles = generateColors(colorGroups, colorTokens);

  const customIdentifiers = exportConfiguration.customIdentifiers;
  const colorFiles = generateColors(prunedTree, dartKeywords, customIdentifiers);
  const typographyFiles = generateTypography(prunedTree, dartKeywords, customIdentifiers);
  const shadowFiles = generateShadow(prunedTree, dartKeywords, customIdentifiers);
  const allFiles = [
    ...colorFiles,
    ...typographyFiles,
    ...shadowFiles,
  ];

  const wrappedFiles = allFiles.map(file => {
    let content = `\n${file.content}`;

    if (exportConfiguration.generateDisclaimer) {
      content = `/* This file was generated by Supernova, don't change by hand */\n${content}`;
    }

    return FileHelper.createTextFile({
      relativePath: `${basePath}${file.path}`,
      fileName: `${file.name}.dart`,
      content,
    });
  });

  return wrappedFiles;
})

/** Exporter configuration. Adheres to the `ExporterConfiguration` interface and its content comes from the resolved default configuration + user overrides of various configuration keys */
export const exportConfiguration = Pulsar.exportConfig<ExporterConfiguration>()

export enum TestFormat {
  tetest = "tetest",
  huietest = "huietest",
  zhopatest = "zhopatest",
}
